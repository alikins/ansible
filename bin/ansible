#!/usr/bin/env python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

########################################################
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

__requires__ = ['ansible']
try:
    import pkg_resources
except Exception:
    # Use pkg_resources to find the correct versions of libraries and set
    # sys.path appropriately when there are multiversion installs.  But we
    # have code that better expresses the errors in the places where the code
    # is actually used (the deps are optional for many code paths) so we don't
    # want to fail here.
    pass

import os
import shutil
import sys
import traceback

# for debug
from multiprocessing import Lock
import multiprocessing
import logging
import debug_logger

LOG_FORMAT = "%(asctime)s [%(name)s %(levelname)s] pid=%(process)d,%(processName)s tid=%(thread)d:%(threadName)s %(funcName)s:%(lineno)d - %(message)s"
log = logging.getLogger("ansible")
log.setLevel(multiprocessing.SUBDEBUG)
handler = logging.StreamHandler(sys.stderr)
handler.setLevel(multiprocessing.SUBDEBUG)
formatter = debug_logger.ColorFormatter(use_color=True)
formatter.use_thread_color = True
#handler.setFormatter(logging.Formatter(LOG_FORMAT))
handler.setFormatter(formatter)
root_log = logging.getLogger()
root_log.setLevel(multiprocessing.SUBDEBUG)
root_log.addHandler(handler)
#logging.basicConfig(level=multiprocessing.SUBDEBUG, format=LOG_FORMAT)
#mplog = multiprocessing.log_to_stderr()
mplog = multiprocessing.get_logger()
mplog.setLevel(multiprocessing.SUBDEBUG)
mplog2 = logging.getLogger('multiprocessing')
mplog2.setLevel(multiprocessing.SUBDEBUG)
mplog2.propagate = True

#import coloredlogs
#styles = coloredlogs.DEFAULT_FIELD_STYLES
#styles['threadName'] = {'color':'red'}
#coloredlogs.install(fmt=LOG_FORMAT, field_styles=styles)

import logging_tree
logging_tree.printout()

import ansible.constants as C
from ansible.errors import AnsibleError, AnsibleOptionsError, AnsibleParserError
from ansible.utils.display import Display
from ansible.module_utils._text import to_text

import signal
def signal_handler(signum, frame):
    log.warning('signal_handler %s %s', signum, frame)
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)

########################################
### OUTPUT OF LAST RESORT ###
class LastResort(object):
    def display(self, msg):
        print(msg, file=sys.stderr)

    def error(self, msg, wrap_text=None):
        print(msg, file=sys.stderr)



########################################

if __name__ == '__main__':
    display = LastResort()
    cli = None
    me = os.path.basename(sys.argv[0])

    try:
        from ansible.logger import setup
        import logging
        # or 'ansible.cli' etc
        log = logging.getLogger('ansible')
        setup.log_setup()
    # TODO: if we totally fail to setup any logging, decide if thats fatal
    except Exception as e:
        sys.stderr.write('%s\n' % e)
        raise

    log.debug('================ ansible startup argv=%s ===================', sys.argv[:])
    log.debug('The logger is %s', log)
    log.debug('||| debug |||')
    log.info('||| info |||')
    log.warning('||| warning |||')
    log.error('||| error |||')
    log.critical('||| critical |||')

    # FIXME: remove...  dump out the logging config post yaml setup
    # NOTE: since we don't log all the python modules we are going to use until much later (plugins, etc)
    #       the logging_tree output here misses anything setup later (like requests logging setup for ex)
    try:
        import logging_tree
        logging_tree.printout()
    except Exception:
        # We have some sort of log setup here, and this isn't important
        log.exception()

    try:
        display = Display()
        display.debug("starting run")
        log.debug("starting run")

        sub = None
        try:
            if me.find('-') != -1:
                target = me.split('-')
                if len(target) > 1:
                    sub = target[1]
                    myclass = "%sCLI" % sub.capitalize()
                    mycli = getattr(__import__("ansible.cli.%s" % sub, fromlist=[myclass]), myclass)
            elif me == 'ansible':
                from ansible.cli.adhoc import AdHocCLI as mycli
            else:
                raise AnsibleError("Unknown Ansible alias: %s" % me)
        except ImportError as e:
            # ImportError members have changed in py3
            log.exception()
            if 'msg' in dir(e):
                msg = e.msg
            else:
                msg = e.message
            if msg.endswith(' %s' % sub):
                raise AnsibleError("Ansible sub-program not implemented: %s" % me)
            else:
                raise

        try:
            args = [to_text(a, errors='surrogate_or_strict') for a in sys.argv]
        except UnicodeError as e:
            display.error('Command line args are not in utf-8, unable to continue.  Ansible currently only understands utf-8')
            log.error('Command line args are not in utf-8, unable to continue.  Ansible currently only understands utf-8')

            display.display(u"The full traceback was:\n\n%s" % to_text(traceback.format_exc()))
            log.exception(e)

            exit_code = 6
        else:
            cli = mycli(args)
            cli.parse()
            exit_code = cli.run()

    except AnsibleOptionsError as e:
        cli.parser.print_help()
        display.error(to_text(e), wrap_text=False)
        log.exception(e)
        exit_code = 5
    except AnsibleParserError as e:
        display.error(to_text(e), wrap_text=False)
        log.exception(e)
        exit_code = 4
# TQM takes care of these, but leaving comment to reserve the exit codes
#    except AnsibleHostUnreachable as e:
#        display.error(str(e))
#        exit_code = 3
#    except AnsibleHostFailed as e:
#        display.error(str(e))
#        exit_code = 2
    except AnsibleError as e:
        display.error(to_text(e), wrap_text=False)
        log.exception(e)
        exit_code = 1
    except KeyboardInterrupt as e:
        log.exception(e)
        display.error("User interrupted execution")
        log.exception(e)
        exit_code = 99
    except Exception as e:
        have_cli_options = cli is not None and cli.options is not None
        display.error("Unexpected Exception: %s" % to_text(e), wrap_text=False)
        log.exception(e)
        if not have_cli_options or have_cli_options and cli.options.verbosity > 2:
            log_only = False
        else:
            display.display("to see the full traceback, use -vvv")
            log_only = True 
        display.display(u"the full traceback was:\n\n%s" % to_text(traceback.format_exc()), log_only=log_only)
        exit_code = 250
    finally:
        # Remove ansible tempdir
        log.debug('finally cleanup')
        shutil.rmtree(C.DEFAULT_LOCAL_TMP, True)

    log.debug('exiting with code %s', exit_code)
    sys.exit(exit_code)
