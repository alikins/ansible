

!vault:  cipher text
        assumes the value of the field is a '1.1' style vault encrypted blob. It will use the
        same mechanism to decrypt as current (ie, assumes one ansible vault key_id, --ask-vault-pass, etc)
        possibly only support vault format 1.1

!vault:ciphertext : cipher text
                   same as above

!vault:ciphertext:cipher=AES256:key_id=my_orgs_key :
                    cipher text, but with the potential for additional metadata like the name of the key to use to decrypt

!vault:plaintext :  plaintext
                  Only 'ansible-vault' should understand !vault-plaintext
                  'ansible-playbook' should consider presense of !vault-plaintext a fatal error
                  (Or maybe, if we live dangerously, as a super tainted 'unsafe' var...)

!vault:plaintext:cipher=AES256:key_id=my_orgs_key : When encrypting, use the metadata params

ansible-vault edit|encrypt could read a yml file, find the !vault-plaintext items, and encrypt them



Possible to use dict for RHS of !vault:ciphertext

!vault:
    - ciphertext: <the encrypted blob as before>
                 depending on if we support additional formats, the blob here may be the envelope or the 'ascii armored' version of the content
                 (for, a gpg blob or a pkcs7 blob/pem)
    - key_id: the id of the key used to encrypt it
    - cipher: the name/version of the cipher (redundant with current vault format header, but would not be in future)
              - hook to potentially support other formats
    - public_key_id: identifier indicating which public key was used if we use PKI


- Replace AnsibleVaultUnicode with AnsibleVaultEncryptedUnicode

- add AnsibleVaultPlaintextUnicode for use with !vault-plaintext  (that only ansible-vault encrypting tools understand...)


Things to keep in mind:

- will likely need to support other ciphers, including public/private key tools (ie, gpg)

- May want to support vault strings being decrypted only on the remote node end
  - either via shared secret and symetric crypto
       - basically like current vault, but the remote end would know the passphrase to decrypt
       - could potentially support a shared secret / key for each inventory item
  - via PKI tools
       - remote end private key would be able to decrypt the ciphertext passed to it.
  - modules would need to include code for decrypt
    - simplest likely exec'ing gpg
  - module arg spec would also need to understand encrypted args being passed to it

- keep things abstract enough that could eventually use HSM/pkcs11

- may need to seperate support for 'at rest' crypto and 'in transit', ie one mechanism
  for 'ansible-playbook' to decrypt playbooks, and another mechanism for how we send it
  encrypted to the remote nodes (decrypt playbook with admin team key, send to remote with per system key)
